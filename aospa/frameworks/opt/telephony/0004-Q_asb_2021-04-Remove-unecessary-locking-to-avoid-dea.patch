From b38b20ef3193a18d6eeffe71640386de04c34f90 Mon Sep 17 00:00:00 2001
From: Malcolm Chen <refuhoo@google.com>
Date: Tue, 21 Jul 2020 14:27:39 -0700
Subject: [PATCH 4/8] [Q_asb_2021-04] Remove unecessary locking to avoid dead
 lock.

Bug: 160252067
Bug: 173421434
Test: manual - switch to dsds multiple times to make sure no error
happens

Change-Id: I15def5c401811190f0f2ca8d1fa7e44d6387407e
Merged-In: I15def5c401811190f0f2ca8d1fa7e44d6387407e
(cherry picked from commit 93d5117cf5f528ec7ed74b4fe2df7ae7e2d207ff)
---
 .../telephony/SubscriptionController.java     | 95 ++++++++++---------
 1 file changed, 49 insertions(+), 46 deletions(-)

diff --git a/src/java/com/android/internal/telephony/SubscriptionController.java b/src/java/com/android/internal/telephony/SubscriptionController.java
index 929af60963..4010b36c4e 100644
--- a/src/java/com/android/internal/telephony/SubscriptionController.java
+++ b/src/java/com/android/internal/telephony/SubscriptionController.java
@@ -743,6 +743,12 @@ public class SubscriptionController extends ISub.Stub {
         }
     }
 
+    private List<SubscriptionInfo> makeCacheListCopyWithLock(List<SubscriptionInfo> cacheSubList) {
+        synchronized (mSubInfoListLock) {
+            return new ArrayList<>(cacheSubList);
+        }
+    }
+
     /**
      * Get the SubInfoRecord(s) of the currently active SIM(s) - which include both local
      * and remote SIMs.
@@ -752,7 +758,8 @@ public class SubscriptionController extends ISub.Stub {
     @UnsupportedAppUsage
     @Override
     public List<SubscriptionInfo> getActiveSubscriptionInfoList(String callingPackage) {
-        return getSubscriptionInfoListFromCacheHelper(callingPackage, mCacheActiveSubInfoList);
+        return getSubscriptionInfoListFromCacheHelper(callingPackage,
+                makeCacheListCopyWithLock(mCacheActiveSubInfoList));
     }
 
     /**
@@ -763,13 +770,13 @@ public class SubscriptionController extends ISub.Stub {
     public void refreshCachedActiveSubscriptionInfoList() {
         boolean opptSubListChanged;
 
-        synchronized (mSubInfoListLock) {
-            List<SubscriptionInfo> activeSubscriptionInfoList = getSubInfo(
-                    SubscriptionManager.SIM_SLOT_INDEX + ">=0 OR "
-                    + SubscriptionManager.SUBSCRIPTION_TYPE + "="
-                    + SubscriptionManager.SUBSCRIPTION_TYPE_REMOTE_SIM,
-                    null);
+        List<SubscriptionInfo> activeSubscriptionInfoList = getSubInfo(
+                SubscriptionManager.SIM_SLOT_INDEX + ">=0 OR "
+                + SubscriptionManager.SUBSCRIPTION_TYPE + "="
+                + SubscriptionManager.SUBSCRIPTION_TYPE_REMOTE_SIM,
+                null);
 
+        synchronized (mSubInfoListLock) {
             if (activeSubscriptionInfoList != null) {
                 // Log when active sub info changes.
                 if (mCacheActiveSubInfoList.size() != activeSubscriptionInfoList.size()
@@ -784,10 +791,6 @@ public class SubscriptionController extends ISub.Stub {
                 logd("activeSubscriptionInfoList is null.");
                 mCacheActiveSubInfoList.clear();
             }
-
-            // Refresh cached opportunistic sub list and detect whether it's changed.
-            refreshCachedOpportunisticSubscriptionInfoList();
-
             if (DBG_CACHE) {
                 if (!mCacheActiveSubInfoList.isEmpty()) {
                     for (SubscriptionInfo si : mCacheActiveSubInfoList) {
@@ -799,6 +802,9 @@ public class SubscriptionController extends ISub.Stub {
                 }
             }
         }
+
+        // Refresh cached opportunistic sub list and detect whether it's changed.
+        refreshCachedOpportunisticSubscriptionInfoList();
     }
 
     /**
@@ -3038,8 +3044,8 @@ public class SubscriptionController extends ISub.Stub {
 
     @Override
     public List<SubscriptionInfo> getOpportunisticSubscriptions(String callingPackage) {
-        return getSubscriptionInfoListFromCacheHelper(
-                callingPackage, mCacheOpportunisticSubInfoList);
+        return getSubscriptionInfoListFromCacheHelper(callingPackage,
+                makeCacheListCopyWithLock(mCacheOpportunisticSubInfoList));
     }
 
     /**
@@ -3697,36 +3703,34 @@ public class SubscriptionController extends ISub.Stub {
             // the identifier and phone number access checks are not required.
         }
 
-        synchronized (mSubInfoListLock) {
-            // If the caller can read all phone state, just return the full list.
-            if (canReadIdentifiers) {
-                return new ArrayList<>(cacheSubList);
-            }
-            // Filter the list to only include subscriptions which the caller can manage.
-            List<SubscriptionInfo> subscriptions = new ArrayList<>(cacheSubList.size());
-            for (SubscriptionInfo subscriptionInfo : cacheSubList) {
-                int subId = subscriptionInfo.getSubscriptionId();
-                boolean hasCarrierPrivileges = TelephonyPermissions.checkCarrierPrivilegeForSubId(
-                        subId);
-                // If the caller does not have the READ_PHONE_STATE permission nor carrier
-                // privileges then they cannot access the current subscription.
-                if (!canReadPhoneState && !hasCarrierPrivileges) {
-                    continue;
-                }
-                // If the caller has carrier privileges then they are granted access to all
-                // identifiers for their subscription.
-                if (hasCarrierPrivileges) {
-                    subscriptions.add(subscriptionInfo);
-                } else {
-                    // The caller does not have carrier privileges for this subId, filter the
-                    // identifiers in the subscription based on the results of the initial
-                    // permission checks.
-                    subscriptions.add(
-                            conditionallyRemoveIdentifiers(subscriptionInfo, canReadIdentifiers));
-                }
+        // If the caller can read all phone state, just return the full list.
+        if (canReadIdentifiers) {
+            return cacheSubList;
+        }
+        // Filter the list to only include subscriptions which the caller can manage.
+        List<SubscriptionInfo> subscriptions = new ArrayList<>(cacheSubList.size());
+        for (SubscriptionInfo subscriptionInfo : cacheSubList) {
+            int subId = subscriptionInfo.getSubscriptionId();
+            boolean hasCarrierPrivileges = TelephonyPermissions.checkCarrierPrivilegeForSubId(
+                    subId);
+            // If the caller does not have the READ_PHONE_STATE permission nor carrier
+            // privileges then they cannot access the current subscription.
+            if (!canReadPhoneState && !hasCarrierPrivileges) {
+                continue;
+            }
+            // If the caller has carrier privileges then they are granted access to all
+            // identifiers for their subscription.
+            if (hasCarrierPrivileges) {
+                subscriptions.add(subscriptionInfo);
+            } else {
+                // The caller does not have carrier privileges for this subId, filter the
+                // identifiers in the subscription based on the results of the initial
+                // permission checks.
+                subscriptions.add(
+                        conditionallyRemoveIdentifiers(subscriptionInfo, canReadIdentifiers));
             }
-            return subscriptions;
         }
+        return subscriptions;
     }
 
     /**
@@ -3826,14 +3830,13 @@ public class SubscriptionController extends ISub.Stub {
     }
 
     private void refreshCachedOpportunisticSubscriptionInfoList() {
+        List<SubscriptionInfo> subList = getSubInfo(
+                SubscriptionManager.IS_OPPORTUNISTIC + "=1 AND ("
+                        + SubscriptionManager.SIM_SLOT_INDEX + ">=0 OR "
+                        + SubscriptionManager.IS_EMBEDDED + "=1)", null);
         synchronized (mSubInfoListLock) {
             List<SubscriptionInfo> oldOpptCachedList = mCacheOpportunisticSubInfoList;
 
-            List<SubscriptionInfo> subList = getSubInfo(
-                    SubscriptionManager.IS_OPPORTUNISTIC + "=1 AND ("
-                            + SubscriptionManager.SIM_SLOT_INDEX + ">=0 OR "
-                            + SubscriptionManager.IS_EMBEDDED + "=1)", null);
-
             if (subList != null) {
                 subList.sort(SUBSCRIPTION_INFO_COMPARATOR);
             } else {
-- 
2.34.1

