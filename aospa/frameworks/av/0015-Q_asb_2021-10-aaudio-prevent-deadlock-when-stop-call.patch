From ead6a9dfa9abee5856d32b06073dd4b130e1ca99 Mon Sep 17 00:00:00 2001
From: Phil Burk <philburk@google.com>
Date: Wed, 7 Apr 2021 06:30:50 +0000
Subject: [PATCH 15/29] [Q_asb_2021-10] aaudio: prevent deadlock when stop()
 calls disconnect()

Move all calls to send the timestamp into the one timestamp thread.

There was a clear code path that could lead to a deadlock.
If the call to get the timestamp from the HAL returned
an unexpected error code then it would call disconnect().
If that happened below the call to stop() then the
deadlock would occur.

The sequence of calls was AAudioServiceStreamBase::stop()
  which locked mLock,
  then called AAudioServiceStreamBase::stop_l(),
  which called AAudioServiceStreamBase:sendCurrentTimeStamp(),
  which called AAudioServiceStreamMMAP::getFreeRunningPosition(),
  which called disconnect(),
  which locked mLock AGAIN.

It is not clear what would trigger the error return
from the HAL but a routing change may be involved.

The bug was discovered during stress tests and we do not
have a clear repro case.

Bug: 182852602
Bug: 153358911
Test: atest CtsNativeMediaAAudioTestCases
Change-Id: I575f75ece9b459e7412bca293d7338babe76b3a7
Merged-In: I575f75ece9b459e7412bca293d7338babe76b3a7
(cherry picked from commit 45da1b7e3231bf3475cb9ca1a2243a27355c0466)
(cherry picked from commit 347fcbb43477bf7ee0568b113858802b8408aef1)
---
 services/oboeservice/AAudioServiceStreamBase.cpp | 15 +++++++--------
 1 file changed, 7 insertions(+), 8 deletions(-)

diff --git a/services/oboeservice/AAudioServiceStreamBase.cpp b/services/oboeservice/AAudioServiceStreamBase.cpp
index 4a99ae042e..1c6c44d447 100644
--- a/services/oboeservice/AAudioServiceStreamBase.cpp
+++ b/services/oboeservice/AAudioServiceStreamBase.cpp
@@ -227,10 +227,6 @@ aaudio_result_t AAudioServiceStreamBase::pause_l() {
         return result;
     }
 
-    // Send it now because the timestamp gets rounded up when stopStream() is called below.
-    // Also we don't need the timestamps while we are shutting down.
-    sendCurrentTimestamp();
-
     result = stopTimestampThread();
     if (result != AAUDIO_OK) {
         disconnect_l();
@@ -266,9 +262,6 @@ aaudio_result_t AAudioServiceStreamBase::stop_l() {
 
     setState(AAUDIO_STREAM_STATE_STOPPING);
 
-    // Send it now because the timestamp gets rounded up when stopStream() is called below.
-    // Also we don't need the timestamps while we are shutting down.
-    sendCurrentTimestamp(); // warning - this calls a virtual function
     result = stopTimestampThread();
     if (result != AAUDIO_OK) {
         disconnect_l();
@@ -324,10 +317,11 @@ void AAudioServiceStreamBase::run() {
     timestampScheduler.start(AudioClock::getNanoseconds());
     int64_t nextTime = timestampScheduler.nextAbsoluteTime();
     int32_t loopCount = 0;
+    aaudio_result_t result = AAUDIO_OK;
     while(mThreadEnabled.load()) {
         loopCount++;
         if (AudioClock::getNanoseconds() >= nextTime) {
-            aaudio_result_t result = sendCurrentTimestamp();
+            result = sendCurrentTimestamp();
             if (result != AAUDIO_OK) {
                 ALOGE("%s() timestamp thread got result = %d", __func__, result);
                 break;
@@ -339,6 +333,11 @@ void AAudioServiceStreamBase::run() {
             AudioClock::sleepUntilNanoTime(nextTime);
         }
     }
+    // This was moved from the calls in stop_l() and pause_l(), which could cause a deadlock
+    // if it resulted in a call to disconnect.
+    if (result == AAUDIO_OK) {
+        (void) sendCurrentTimestamp();
+    }
     ALOGD("%s() %s exiting after %d loops <<<<<<<<<<<<<< TIMESTAMPS",
           __func__, getTypeText(), loopCount);
 }
-- 
2.35.1

